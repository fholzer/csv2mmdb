package valuecache

import "github.com/maxmind/mmdbwriter/mmdbtype"

type dataMapKey string

// Please note, if you change the order of these fields, please check
// alignment as we end up storing quite a few in memory.
type dataMapValue struct {
	Data mmdbtype.DataType
	key  dataMapKey

	// Alternatively, we could use a weak map for the data map, but I
	// don't see any very good options at the moment. We should revist
	// if something happens with https://github.com/golang/go/issues/43615
	refCount uint32
}

// dataMap is used to deduplicate data inserted into the tree to reduce
// memory usage using keys generated by keyWriter.
type DataMap struct {
	data      map[dataMapKey]*dataMapValue
	keyWriter *keyWriter
}

func NewDataMap() *DataMap {
	return &DataMap{
		data:      map[dataMapKey]*dataMapValue{},
		keyWriter: newKeyWriter(),
	}
}

// store stores the value in the dataMap and returns the dataMapValue for it.
// If the value is already in the dataMap, the reference count for it is
// incremented.
func (dm *DataMap) Store(v mmdbtype.DataType) (*dataMapValue, error) {
	key, err := dm.keyWriter.key(v)
	if err != nil {
		return nil, err
	}

	dmv, ok := dm.data[dataMapKey(key)]
	if !ok {
		dmKey := dataMapKey(key)
		dmv = &dataMapValue{
			key:  dmKey,
			Data: v,
		}
		dm.data[dmKey] = dmv
	}

	dmv.refCount++

	switch v.(type) {
	case mmdbtype.Map:
		vm := v.(mmdbtype.Map)
		for mk, mv := range vm {
			cv, err := dm.Store(mv)
			if err != nil {
				return nil, err
			}
			vm[mk] = cv.Data
		}
		break
	case mmdbtype.Slice:
		va := v.(mmdbtype.Slice)
		for ai, av := range va {
			ev, err := dm.Store(av)
			if err != nil {
				return nil, err
			}
			va[ai] = ev.Data
		}
		break
	}

	return dmv, nil
}

// remove removes a reference to the value. If the reference count
// drops to zero, the value is removed from the dataMap.
func (dm *DataMap) Remove(v *dataMapValue) {
	// This is here mostly so that we don't have to guard against it
	// elsewhere.
	if v == nil {
		return
	}
	v.refCount--

	if v.refCount == 0 {
		delete(dm.data, v.key)
	}

	switch v.Data.(type) {
	case mmdbtype.Map:
		vm := v.Data.(mmdbtype.Map)
		for _, mv := range vm {
			key, err := dm.keyWriter.key(mv)
			if err != nil {
				return
			}
			cv, ok := dm.data[dataMapKey(key)]
			if ok {
				dm.Remove(cv)
			}
		}
		break
	case mmdbtype.Slice:
		va := v.Data.(mmdbtype.Slice)
		for _, av := range va {
			key, err := dm.keyWriter.key(av)
			if err != nil {
				return
			}
			cv, ok := dm.data[dataMapKey(key)]
			if ok {
				dm.Remove(cv)
			}
		}
		break
	}
}
